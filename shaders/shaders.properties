
/*
====================================================================================================

    Copyright (C) 2025 Pyvtron Shaders - Pyvtron

    All Rights Reserved unless otherwise explicitly stated.

====================================================================================================
*/


#
# Shader Properties
#


shadowTranslucent                    = false
vignette                             = false
underwaterOverlay                    = false 
oldLighting                          = false
shadow.culling                       = false
separateAo                           = true
frustum.culling                      = true
dynamicHandLight                     = true

clouds                               = off

#scale.composite3                    = 0.5


#
# Alpha Tests
#


alphaTest.gbuffers_entities=GREATER 0.1
alphaTest.gbuffers_block=GREATER 0.1
alphaTest.gbuffers_terrain=GREATER 0.1
alphaTest.gbuffers_textured=GREATER 0.1
alphaTest.gbuffers_hand=GREATER 0.1
alphaTest.gbuffers_hand_water=GREATER 0.1
alphaTest.gbuffers_water=GREATER 0.1
alphaTest.gbuffers_weather=GREATER 0.1
alphaTest.gbuffers_skybasic=off
alphaTest.gbuffers_skytextured=off
alphaTest.gbuffers_armor_glint=GREATER 0.1


#
# Enable Programms
#


program.gbuffers_armor_glint.enabled = true
program.gbuffers_entities.enabled    = true
program.gbuffers_terrain.enabled     = true
program.gbuffers_water.enabled       = true
program.gbuffers_weather.enabled     = true
program.gbuffers_block.enabled       = true
program.gbuffers_textured.enabled    = true
program.gbuffers_hand.enabled        = true
program.deferred.enabled             = (PBR)
program.composite2.enabled           = MOTIONBLUR
program.composite3.enabled           = BLOOM

#
# Textures
#


texture.noise                        = Images/Noise.png
texture.gbuffers.gaux4               = Images/Skyboxes.png


#
# Profiles
#


profile.LITE                         = shadowMapResolution:512    shadowDistance:128.0  WINDY_TERRAIN  VL_QUALITY:0  WATER_SAMPLES:250
profile.LOW                          = shadowMapResolution:1024   shadowDistance:224.0  WINDY_TERRAIN  VL_QUALITY:0  WATER_SAMPLES:150
profile.MEDIUM                       = shadowMapResolution:2048   shadowDistance:384.0  WINDY_TERRAIN  VL_QUALITY:1  WATER_SAMPLES:450
profile.HIGH                         = shadowMapResolution:3072   shadowDistance:384.0  WINDY_TERRAIN  VL_QUALITY:1  WATER_SAMPLES:500
profile.VERY_HIGH                    = shadowMapResolution:4096   shadowDistance:384.0  WINDY_TERRAIN  VL_QUALITY:1  WATER_SAMPLES:500
profile.ULTRA                        = shadowMapResolution:6344   shadowDistance:384.0  WINDY_TERRAIN  VL_QUALITY:2  WATER_SAMPLES:600
profile.EXTREME                      = shadowMapResolution:16384  shadowDistance:384.0  WINDY_TERRAIN  VL_QUALITY:2  WATER_SAMPLES:600 


# 
# Shader Option Menu
#


screen                               = <empty> [PYVTRON_SHADERS] <profile> <empty> [VOLUMETRIC_FOG] [UNDERWATER_FOG] [LIGHTING] [SURFACE] [POSTPROCESSING] [OTHER]
screen.VOLUMETRIC_FOG                = VOLUMETRIC_FOG FOG_STRENGTH <empty> NETHER_VOLUMETRIC_FOG NETHER_FOG_STRENGTH <empty> END_VOLUMETRIC_FOG END_FOG_STRENGTH 
screen.LIGHTING                      = [LIGHT_SOURCE] [SHADOWS] 
screen.LIGHT_SOURCE                  = [VOLUMETRIC_LIGHT] [TORCHLIGHT_TEMPERATURE] AMBIENT_LIGHT_BRIGHTNESS SUNLIGHT_BRIGHTNESS sunPathRotation LIGHT_SCATTERING
screen.VOLUMETRIC_LIGHT              = LIGHT_SCATTERING VOLUMETRIC_LIGHT_SAMPLES VOLUMETRIC_LIGHT_RENDER_QUALITY VOLUMETRIC_LIGHT_RENDERDISTANCE
screen.TORCHLIGHT_TEMPERATURE        = TEMPERATURE TORCHLIGHT_TEMPERATURE
screen.SHADOWS                       = SOFT_SHADOWS FIX_SUNLIGHT_LEAK shadowMapResolution <empty> shadowDistance SHADOW_BRIGHTNESS shadowDistanceRenderMul 
screen.SURFACE                       = [RAIN] [WATER] [PBR_POM] <empty> TEXTURE_RESOLUTION 
screen.RAIN                          = RAINDROP_REFRACTION 
screen.WATER                         = WATER_REFRACTION_STRENGTH WATER_WAVE_SPEED WATER_WAVE_SCALE WATER_WAVES_AMOUNT <empty> WATER_RED_AMOUNT WATER_GREEN_AMOUNT WATER_BLUE_AMOUNT
screen.SSR                           = SSR_SAMPLES SSR_METHOD
screen.PBR_POM                       = AUTO_BUMP PBR POM POM_QUALITY POM_DEPTH TORCH_NORMALS NORMAL_MAP_BUMPMULT
screen.POSTPROCESSING                = [BLOOM] [TONEMAPING] [WIND] [VIGNETTE] [LENS_FLARE] [BLUR] [HEATWAVE] [DEPTH_OF_FIELD] EXPOSURE CHROMATIC_ABERRATION FILM_GRAIN centerDepthHalflife <empty> DIRTY_LENS
screen.TONEMAPING                    = TONEMAPPING SATURATION CONTRAST WHITESCALE BRIGHTNESS
screen.WIND                          = WINDY_TERRAIN WIND_SPEED
screen.BLOOM                         = BLOOM BLOOM_SAMPLES
screen.VIGNETTE                      = VIGNETTE VIGNETTE_STRENGTH VIGNETTE_SHARPNESS
screen.LENS_FLARE                    = LENS_FLARE LENS_POWER
screen.BLUR                          = MOTIONBLUR MOTIONBLUR_AMOUNT DISTANCE_BLUR MOTION_BLUR_STRENGTH MOTION_BLUR_DITHER MOTION_BLUR_QUALITY MOTION_BLUR_SUTTER_ANGLE
screen.HEATWAVE                      = NETHER_HEATWAVE NETHER_HEATWAVE_SPEED NETHER_HEATWAVE_SIZE <empty> HEATWAVE HEATWAVE_SPEED HEATWAVE_SIZE <empty> END_HEATWAVE END_HEATWAVE_SPEED END_HEATWAVE_SIZE
screen.DEPTH_OF_FIELD                = DEPTH_OF_FIELD DEPTH_OF_FIELD_AMOUNT DEPTH_OF_FIELD_RANGE
screen.UNDERWATER_FOG                = UNDERWATER_FOG UNDERWATER_FOG_STRENGTH UNDERWATER_FOG_BRIGHTNESS
screen.OTHER                         = OVERRIDE_FOLIAGE_COLOR


#
# Sliders
#

 
sliders                              = FOG_STRENGTH NETHER_FOG_STRENGTH END_FOG_STRENGTH AMBIENT_LIGHT_BRIGHTNESS SUNLIGHT_BRIGHTNESS sunPathRotation VOLUMETRIC_LIGHT_SAMPLES VOLUMETRIC_LIGHT_RENDER_QUALITY VOLUMETRIC_LIGHT_RENDERDISTANCE TEMPERATURE TORCHLIGHT_TEMPERATURE shadowMapResolution shadowDistance SHADOW_BRIGHTNESS TEXTURE_RESOLUTION WATER_REFRACTION_STRENGTH WATER_WAVE_SPEED WATER_WAVE_SCALE WATER_WAVES_AMOUNT WATER_RED_AMOUNT WATER_GREEN_AMOUNT WATER_BLUE_AMOUNT SSR_SAMPLES POM_QUALITY POM_DEPTH NORMAL_MAP_BUMPMULT EXPOSURE centerDepthHalflife WIND_SPEED BLOOM_SAMPLES VIGNETTE_STRENGTH VIGNETTE_SHARPNESS LENS_POWER MOTIONBLUR_AMOUNT MOTION_BLUR_STRENGTH MOTION_BLUR_DITHER MOTION_BLUR_QUALITY MOTION_BLUR_SUTTER_ANGLE NETHER_HEATWAVE_SPEED NETHER_HEATWAVE_SIZE HEATWAVE_SPEED HEATWAVE_SIZE END_HEATWAVE_SPEED END_HEATWAVE_SIZE DEPTH_OF_FIELD DEPTH_OF_FIELD_AMOUNT DEPTH_OF_FIELD_RANGE UNDERWATER_FOG_STRENGTH UNDERWATER_FOG_BRIGHTNESS


#
# Columns
#


screen.columns=1

screen.VOLUMETRIC_FOG.columns         = 1
screen.LIGHTING.columns               = 1
screen.LIGHT_SOURCE.columns           = 1
screen.VOLUMETRIC_LIGHT.columns       = 1
screen.TORCHLIGHT_TEMPERATURE.columns = 1
screen.SHADOWS.columns                = 1
screen.SURFACE.columns                = 1
screen.RAIN.columns                   = 1
screen.WATER.columns                  = 1
screen.SSR.columns                    = 1
screen.PBR_POM.columns                = 1
screen.POSTPROCESSING.columns         = 1
screen.TONEMAPING.columns             = 1
screen.WIND.columns                   = 1
screen.BLOOM.columns                  = 1
screen.VIGNETTE.columns               = 1
screen.LENS_FLARE.columns             = 1
screen.BLUR.columns                   = 1
screen.HEATWAVE.columns               = 1
screen.DEPTH_OF_FIELD.columns         = 1
screen.UNDERWATER_FOG.columns         = 1
screen.OTHER.columns                  = 1


#
# Colortex Sizes And Resolution
#


size.buffer.colortex6=4096 4096


#
# Uniforms
#


uniform.float.rcp240                  = 1.0 / 240.0
uniform.int.framemod                  = frameCounter % 8
uniform.vec2.viewSize                 = vec2(viewWidth, viewHeight)
uniform.vec2.texelSize                = vec2(1.0 / viewWidth, 1.0 / viewHeight)
uniform.vec3.shadowVec                = vec3(shadowLightPosition.x * 0.01, shadowLightPosition.y * 0.01, shadowLightPosition.z * 0.01)


variable.float.sunVectorNorm          = 1.0 / sqrt((sunPosition.x * sunPosition.x) + (sunPosition.y * sunPosition.y) + (sunPosition.z * sunPosition.z))
uniform.vec3.sunVectorView            = vec3(sunPosition.x * sunVectorNorm, sunPosition.y * sunVectorNorm, sunPosition.z * sunVectorNorm)
variable.float.sunVectorX             = gbufferModelViewInverse.0.0 * sunPosition.x + gbufferModelViewInverse.1.0 * sunPosition.y + gbufferModelViewInverse.2.0 * sunPosition.z
variable.float.sunVectorY             = gbufferModelViewInverse.0.1 * sunPosition.x + gbufferModelViewInverse.1.1 * sunPosition.y + gbufferModelViewInverse.2.1 * sunPosition.z
variable.float.sunVectorZ             = gbufferModelViewInverse.0.2 * sunPosition.x + gbufferModelViewInverse.1.2 * sunPosition.y + gbufferModelViewInverse.2.2 * sunPosition.z
uniform.vec3.sunVector                = vec3(sunVectorX * sunVectorNorm, sunVectorY * sunVectorNorm, sunVectorZ * sunVectorNorm)

variable.float.moonVectorNorm         = 1.0 / sqrt((moonPosition.x * moonPosition.x) + (moonPosition.y * moonPosition.y) + (moonPosition.z * moonPosition.z))
uniform.vec3.moonVectorView           = vec3(moonPosition.x * moonVectorNorm, moonPosition.y * moonVectorNorm, moonPosition.z * moonVectorNorm)
variable.float.moonVectorX            = gbufferModelViewInverse.0.0 * moonPosition.x + gbufferModelViewInverse.1.0 * moonPosition.y + gbufferModelViewInverse.2.0 * moonPosition.z
variable.float.moonVectorY            = gbufferModelViewInverse.0.1 * moonPosition.x + gbufferModelViewInverse.1.1 * moonPosition.y + gbufferModelViewInverse.2.1 * moonPosition.z
variable.float.moonVectorZ            = gbufferModelViewInverse.0.2 * moonPosition.x + gbufferModelViewInverse.1.2 * moonPosition.y + gbufferModelViewInverse.2.2 * moonPosition.z
uniform.vec3.moonVector               = vec3(moonVectorX * moonVectorNorm, moonVectorY * moonVectorNorm, moonVectorZ * moonVectorNorm)

variable.float.shadowLightVectorNorm  = 1.0 / sqrt((shadowLightPosition.x * shadowLightPosition.x) + (shadowLightPosition.y * shadowLightPosition.y) + (shadowLightPosition.z * shadowLightPosition.z))
uniform.vec3.shadowLightVectorView    = vec3(shadowLightPosition.x * shadowLightVectorNorm, shadowLightPosition.y * shadowLightVectorNorm, shadowLightPosition.z * shadowLightVectorNorm)
variable.float.shadowLightVectorX     = gbufferModelViewInverse.0.0 * shadowLightPosition.x + gbufferModelViewInverse.1.0 * shadowLightPosition.y + gbufferModelViewInverse.2.0 * shadowLightPosition.z
variable.float.shadowLightVectorY     = gbufferModelViewInverse.0.1 * shadowLightPosition.x + gbufferModelViewInverse.1.1 * shadowLightPosition.y + gbufferModelViewInverse.2.1 * shadowLightPosition.z
variable.float.shadowLightVectorZ     = gbufferModelViewInverse.0.2 * shadowLightPosition.x + gbufferModelViewInverse.1.2 * shadowLightPosition.y + gbufferModelViewInverse.2.2 * shadowLightPosition.z
uniform.vec3.shadowLightVector        = vec3(shadowLightVectorX * shadowLightVectorNorm, shadowLightVectorY * shadowLightVectorNorm, shadowLightVectorZ * shadowLightVectorNorm)

#ifndef PPT_NONE
    #define PPT_NONE 0
#endif

#ifndef PPT_RAIN
    #define PPT_RAIN 1
#endif

#ifndef PPT_SNOW
    #define PPT_SNOW 2
#endif


uniform.float.biome_arid              = smooth(if(biome_category == CAT_DESERT || biome_category == CAT_MESA || biome_category == CAT_SAVANNA, 1.0, 0.0), 30, 30)
uniform.float.biome_may_rain          = smooth(if(biome_precipitation == PPT_RAIN, 1.0, 0.0), 30, 30)
uniform.float.biome_may_sandstorm     = smooth(if(biome_category == CAT_DESERT || biome_category == CAT_MESA, 1.0, 0.0), 30, 30)



